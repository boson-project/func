package e2e

import (
	"fmt"
	cli "github.com/boson-project/func/test/cli"
	"github.com/boson-project/func/test/e2e/utils"
	"os"
	"strings"
	"testing"
	"time"
)

const (
	registry = "localhost:5000/func"
	// namespace = "func" // using current namespace set for integration (func)
)


type ValidateDeployment func(t *testing.T, funcCli *cli.TestShellCli, functionUrl string)

type TestDeployScenario struct {
	FuncName string
	Runtime string
	PerformReadinessTest bool
	PerformLivenessTest bool
	DeploymentValidator ValidateDeployment

	functionFullPath string
	// Flag that indicates function is currently deployed. Needed for cleanup
	isFunctionDeployed bool
}



func (scenario *TestDeployScenario) cleanup(funcCli *cli.TestShellCli) {
	if scenario.isFunctionDeployed {
		funcCli.SourceDir(scenario.functionFullPath)
		funcCli.Run("delete")
	}
	err := os.RemoveAll(scenario.functionFullPath)
	if err != nil {
		fmt.Printf("Error deleting target function dir %v\n", err.Error())
	}
}


// RunTestScenario Tests a Full End to End HTTP Triggered Function
// This scenarios simulates end user experience to deploy the default
// function (generated by func create command) in a cluster
func (scenario *TestDeployScenario) RunTestScenario(t *testing.T) {

	// Setup

	functionName := scenario.FuncName
	runtimeName := scenario.Runtime
	basePath := os.TempDir() + "/test/"
	functionFullPath := basePath + functionName

	assert := NewAsserts(t)
	dockerCli := cli.NewDockerCli(t)
	funcCli := cli.NewFuncCli(t)
	kubectlCli := cli.NewKubectlCli(t)

	err := os.RemoveAll(functionFullPath)
	if err != nil {
		t.Fatalf("Error deleting target function dir %v", err.Error())
	}


	defer scenario.cleanup(funcCli)

	// -------------------------------
	// 1) Create a new function
	// func create nodefunc -l node
	// -------------------------------
	funcCli.LogStep("Creating " + runtimeName + " function")
	cmd := funcCli.Run("create", functionFullPath, "-l", runtimeName)

	assert.StringContains(cmd.Stdout, functionName)
	assert.StringContains(cmd.Stdout, runtimeName)
	assert.StringContains(cmd.Stdout, "http")
	if _, err := os.Stat(functionFullPath + "/func.yaml"); os.IsNotExist(err) {
		t.Fatal("func.yaml file does not exists on function project directory\n");
	}

	// -------------------------------
	// 2) Deploys the function
	// docker/podman login <registry>
	// cd <function path>
	// func deploy -r <registry>
	// -------------------------------
	funcCli.LogStep("Deploying " + runtimeName + " function")
	dockerCli.RunSilent("login", "-u", "user", "-p", "password", registry)

	funcCli.SourceDir(functionFullPath)
	cmd = funcCli.RunSilent("deploy", "-r", registry)

	assert.MustMatch(cmd.Stdout, "Function deployed at URL")
	scenario.isFunctionDeployed = true

	// -------------------------------
	// 3) Waits functions to become ready.
	// watch func list until returns True
	// -------------------------------
	funcCli.LogStep("Checking deployed function")
	funcCli.Run("list")

	funcCli.LogStep("Waiting Function to become Ready")
	if !WaitFunctionToBecomeReady(funcCli, functionName) {
		t.Fatal("Function never got ready. Timeout.")
	}

	// -------------------------------
	// 4) Call Probe URLs
	// URL=$(kubectl get ksvc nodefunc -o jsonpath='{.status.url}')
	// curl $URL/health/readiness
	// curl $URL/health/liveness
	// -------------------------------
	funcCli.LogStep("Calling Probe URLs (Readiness and Liveness)")

	cmd = kubectlCli.Run("get", "ksvc", functionName, "-o", "jsonpath='{.status.url}'")
	assert.NotEmpty(cmd.Stdout, "Unable to retrieve Function URL")

	functionUrl := strings.ReplaceAll(cmd.Stdout, `'`, "")

	if scenario.PerformReadinessTest {
		_, statusCode := utils.HttpGet(t, functionUrl + "/health/readiness")
		assert.Http2xxWithMessage(statusCode, "Unable to call Readiness Probe endpoint")
	}

	if scenario.PerformLivenessTest {
		_, statusCode := utils.HttpGet(t, functionUrl + "/health/liveness")
		assert.Http2xxWithMessage(statusCode, "Unable to call Liveness Probe endpoint")
	}

	if scenario.DeploymentValidator != nil {
		funcCli.LogStep("Deployment validator")
		scenario.DeploymentValidator(t, funcCli, functionUrl)
	}

	// -------------------------------
	// 5) Redeploy Function
	//    Check for new revision to get ready and responsive
	// -------------------------------
	funcCli.LogStep("Redeploy function")
	prevFunctionRevision := GetLatestReadyFunctionRevision(kubectlCli, functionName)

	funcCli.SourceDir(functionFullPath)
	cmd = funcCli.RunSilent("deploy", "-r", registry)
	assert.MustMatch(cmd.Stdout, "Function updated")

	time.Sleep(3 * time.Second)
	t.Log("Waiting Function to become ready")
	if !WaitFunctionToBecomeReady(funcCli, functionName) {
		t.Fatal("Function never got ready after redeploy. Timeout.")
	}

	newFunctionRevision := GetLatestReadyFunctionRevision(kubectlCli, functionName)
	assert.True(newFunctionRevision != "", "Unable to retrieve function revision")
	assert.True(newFunctionRevision != prevFunctionRevision, "Previous Function Revision matches current function revision")


	// -------------------------------
	// 6) Deletes function
	// func delete
	// func list -> ensure cleaned
	// -------------------------------

	funcCli.LogStep("Deleting function")
	cmd = funcCli.Run("delete")
	scenario.isFunctionDeployed = false
	assert.StringContains(cmd.Stdout, "Removing")
	assert.StringContains(cmd.Stdout, functionName)

	funcCli.LogStep("Checking function was removed")
	cmd = kubectlCli.Run( "get", "ksvc", functionName)
	assert.StringContains(cmd.Stderr, "not found")

	cmd = funcCli.Run( "list")
	assert.StringNotContains(cmd.Stdout, functionName)

}

